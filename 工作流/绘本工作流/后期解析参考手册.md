好的。基于我们之前的API研究报告和您设计的表单结构，这是一份用于在n8n中构建后端解析程序的开发手册。

-----

# Sora 2 API 表单解析器：n8n 后端开发手册

## 1\. 概述

本手册为n8n开发者提供技术指导，用于解析“Sora 2 API：一致性提示词生成器”表单的JSON输出，并将其转换为对OpenAI Sora 2 API的单个、结构化API请求。

### 核心理念

此n8n工作流的核心任务是将用户在表单中分离的、易于理解的输入（如镜头、光照、角色）聚合成一个单一的、高度结构化的`prompt`字符串。这种聚合依赖于两个关键概念：

1.  **风格化脊柱 (Style Spine)**：一个包含所有全局美学指令（风格、镜头、光照、调色板、氛围）的可重用文本块 [1]。
2.  **多镜头故事板 (Multi-Shot Storyboarding)**：一种提示词技术，其中每个镜头都作为独立的文本块进行描述，并通过编程方式与“风格化脊柱”和角色描述相结合，以强制实现跨镜头的一致性 [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]。

### 预估的n8n工作流概览

1.  **Webhook (Trigger)**：接收来自前端表单的POST请求（JSON体）。
2.  **Set (Parse\_Inputs)**：将传入JSON的各个部分（API参数、风格输入、故事板数组）提取到独立的n8n变量中，以便清晰处理。
3.  **Code (Build\_Prefixes)**：使用JavaScript构建条件化的、可重用的前缀字符串（`styleSpineString` 和 `characterString`）。对于这种复杂的条件字符串构建，`Code`节点比`Set`节点更清晰、更易于维护。
4.  **Item Lists (Split\_Shots)**：获取`storyboard`数组，并将其拆分为单独的n8n项目，以便进行循环处理。
5.  **Set (Build\_Shot\_String)**：*（在循环中为每个镜头运行）* 将`styleSpineString`、`characterString`和当前镜头的特定描述连接成该镜头的最终提示词块。
6.  **Aggregate (Combine\_Strings)**：将所有单独的`finalShotString`重新组合成一个由换行符分隔的单一文本字符串。
7.  **Set (Build\_API\_Body)**：构建将发送到OpenAI API的最终JSON对象，包括处理可选的`input_reference`字段。
8.  **HTTP Request (Call\_Sora\_API)**：使用最终构建的JSON体向OpenAI API端点发出POST请求。

-----

## 2\. 节点详细配置

### 1\. Webhook 节点 (Trigger)

此节点是工作流的入口点。

  * **Authentication**: `None` (或根据您的安全策略设置)
  * **HTTP Method**: `POST`
  * **Path**: (设置为您的唯一端点，例如 `sora-parser`)
  * **Response Mode**: `On Received`

**预期的传入JSON体 (来自表单):**
您的n8n工作流将收到类似以下结构的JSON。`storyboard`字段是一个数组，这是循环的核心。

```json
{
  "body": {
    "model": "sora-2-pro",
    "size": "1280x720",
    "seconds": "8",
    "input_reference_url": "https://...",
    "style": {
      "main_style": "Cinematic",
      "lens": "85mm lens",
      "depth_of_field": "Shallow DOF",
      "lighting_style": ["Volumetric light", "Golden hour"],
      "mood": "Cinematic and tense",
      "palette_anchors": "amber, cream, walnut brown"
    },
    "character": {
      "workflow": "text_description",
      "char1_desc": "一个30多岁的男人，方下巴，高颧骨...",
      "char2_desc": "一个女人，穿着红色连衣裙..."
    },
    "storyboard":,
    "audio": {
      "bgm": "soft jazz in the background"
    }
  }
}
```

### 2\. Set 节点 (Parse\_Inputs)

此节点将传入的数据分解为更易于管理的变量。

  * **Mode**: `Keep Only Set`
  * **Properties**:
      * `api_params` (Expression):
        ```javascript
        {{ {
            model: $json.body.model,
            size: $json.body.size,
            seconds: $json.body.seconds
          } 
        }}
        ```
      * `input_reference_url` (Expression): `{{ $json.body.input_reference_url }}`
      * `style_inputs` (Expression): `{{ $json.body.style }}`
      * `character_inputs` (Expression): `{{ $json.body.character }}`
      * `audio_inputs` (Expression): `{{ $json.body.audio }}`
      * `storyboard_array` (Expression): `{{ $json.body.storyboard }}`

### 3\. Code 节点 (Build\_Prefixes)

这是工作流的核心逻辑。它构建`styleSpineString`和`characterString`，这些字符串将被添加到*每个*镜头中以强制保持一致性。使用Code节点可以轻松处理条件逻辑（例如，如果用户没有选择镜头，则不添加它）。

  * **JavaScript**:
    ```javascript
    const style = $('Parse_Inputs').item.json.style_inputs;
    const character = $('Parse_Inputs').item.json.character_inputs;
    const audio = $('Parse_Inputs').item.json.audio_inputs;

    let style_parts =;
    let char_parts =;

    // --- 构建风格化脊柱 (Style Spine) ---
    if (style.main_style) {
      style_parts.push(style.main_style);
    }
    if (style.lens && style.lens!== '-- 默认 --') {
      style_parts.push(style.lens);
    }
    if (style.depth_of_field) {
      style_parts.push(style.depth_of_field);
    }
    if (style.lighting_style && style.lighting_style.length > 0) {
      style_parts.push(style.lighting_style.join(', '));
    }
    if (style.mood) {
      style_parts.push(`Mood: ${style.mood}`);
    }
    if (style.palette_anchors) {
      style_parts.push(`Palette anchors: ${style.palette_anchors}`);
    }
    if (audio.bgm && audio.bgm!== '-- 自动 (情境感知) --' && audio.bgm!== '无 (None)') {
      style_parts.push(audio.bgm);
    }

    // --- 构建角色描述 (Character Descriptions) ---
    // 仅当用户选择“文本描述”工作流时才添加
    if (character.workflow === 'text_description') {
      if (character.char1_desc) {
        char_parts.push(`Character 1: ${character.char1_desc}`);
      }
      if (character.char2_desc) {
        char_parts.push(`Character 2: ${character.char2_desc}`);
      }
    }

    // 格式化为最终的前缀字符串
    const styleSpineString = style_parts.join('. ');
    const characterString = char_parts.join('. ');

    // 返回一个新项目，以便后续节点可以访问它
    return;
    ```

### 4\. Item Lists 节点 (Split\_Shots)

此节点接收`storyboard_array`并为每个镜头创建一个单独的n8n项目。

  * **Operation**: `Split Out Items`
  * **Field to Split**: `{{ $('Parse_Inputs').item.json.storyboard_array }}`

### 5\. Set 节点 (Build\_Shot\_String)

此节点将为**循环中的每个镜头**执行一次。它将全局前缀（来自`Build_Prefixes`）与当前镜头的特定细节结合起来。

  * **Mode**: `Append`
  * **Properties**:
      * `finalShotString` (Expression):
        ```javascript
        {{ 
         .filter(Boolean).join('. ') 
        }}
        ```
        *(注: `.filter(Boolean)` 是一个JavaScript技巧，用于删除任何空字符串或null值，避免在连接时出现多余的句点。)*

### 6\. Aggregate 节点 (Combine\_Strings)

此节点等待所有镜头完成处理，然后将它们合并回一个单一的文本字符串。

  * **Operation**: `Concatenate`
  * **Source Field**: `finalShotString`
  * **Separator**: `\n\n` (使用两个换行符来清晰地分隔Sora 2的镜头块 [5, 7, 8, 12])

### 7\. Set 节点 (Build\_API\_Body)

此节点准备发送到Sora 2 API的最终JSON负载。

  * **Mode**: `Keep Only Set`
  * **Properties**:
      * `model` (Expression): `{{ $('Parse_Inputs').item.json.api_params.model }}`
      * `size` (Expression): `{{ $('Parse_Inputs').item.json.api_params.size }}`
      * `seconds` (Expression): `{{ $('Parse_Inputs').item.json.api_params.seconds }}`
      * `prompt` (Expression): `{{ $json.string }}` (这是`Aggregate`节点的输出)
      * `input_reference` (Expression):
        ```javascript
        {{ 
          $('Parse_Inputs').item.json.input_reference_url 
         ? $('Parse_Inputs').item.json.input_reference_url 
          : undefined 
        }}
        ```
        *(注: 将可选字段设为`undefined`，n8n在构建JSON时会自动省略该键，这正是Sora 2 API所期望的。)*

### 8\. HTTP Request 节点 (Call\_Sora\_API)

这是执行Sora 2 API调用的最后一步。

  * **Authentication**: `Header Auth`
      * **Name**: `Authorization`
      * **Value**: `Bearer {{ $credentials.OpenAI_API_Key }}` (假设您的密钥存储在名为`OpenAI_API_Key`的n8n凭证中)
  * **Method**: `POST`
  * **URL**: `https://api.openai.com/v1/videos`
  * **Send Body**: `true`
  * **Body Content Type**: `application/json`
  * **JSON/RAW Parameters**: `true`
  * **Value**: `{{ $json }}` (这会发送来自`Build_API_Body`节点的整个JSON对象)

-----

## 3\. 关键考量与API限制

  * **角色一致性限制**：
      * 此工作流**不能**绕过Sora 2 API的核心限制。
      * **"Cameo"功能在API中不可用** [14, 15, 16]。
      * 使用`input_reference`参数并提供**包含逼真人类面部的图像URL将被拒绝** [14, 17, 18]。
  * **"后期面部替换"工作流**：
      * 如果用户在表单（第4部分）中选择了`"faceswap_later"`，`Build_Prefixes` (Code节点)中的逻辑会*有意地*跳过添加详细的角色描述。
      * 这是正确的行为。开发者应在n8n工作流之外（例如使用DeepFaceLab [19]）处理后续的面部替换，Sora 2 API调用本身将生成一个面部不一致的通用角色。
  * **图像输入 (input\_reference)**：
      * 此工作流假定`input_reference`是一个**URL** [18]。它不处理来自表单的*文件上传*（即二进制数据）。如果需要支持文件上传，`HTTP Request` (Call\_Sora\_API)节点需要被修改为使用`multipart/form-data`，并且`input_reference`字段需要从JSON模式切换到`n8n Binary File`模式。
  * **错误处理**：
      * 生产工作流应在`Call_Sora_API`节点之后添加错误处理逻辑。您可以使用`IF` 或 `Switch` 节点，根据`Call_Sora_API`的HTTP响应状态码（例如，`{{ $json.statusCode }}`）来路由工作流。

-----