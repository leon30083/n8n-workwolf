## 问题与根因
- 查询接口返回体中：顶层 `status` 为 `SUCCESS`，而真正生成完成在 `data.status` 为 `completed`。
- 现有成功判定要求：`status == completed AND video_url 非空`，当顶层是 `SUCCESS` 时被误判为未完成。
- 返回的 `video_url` 可能被反引号和空格包裹（如文档示例），需要清洗再判定与输出。

## 目标
- 不改节点结构与连线，仅更新 4 处表达式，使得：
  - 成功判定：`(data.status==completed OR status==SUCCESS) AND video_url(清洗后) 非空`
  - 返回的 `video_url` 为清洗后的直链

## 最小变更点
1) 更新 Is Ready? (Text)
- 条件组合：AND
  - 条件 A（isNotEmpty）：`={{ ((($json.data && $json.data.status=='completed') || ($json.status=='SUCCESS')) ? 'ok' : '') }}`
  - 条件 B（isNotEmpty）：`={{ ( () => { var v=($json && $json.data && $json.data.video_url) || $json.video_url || ($json.data && $json.data.url) || (function(){var raw=$json&&$json.data?$json.data.resultJson:undefined;var obj=(typeof raw==='string')?JSON.parse(raw):raw;return (obj&&obj.resultUrls&&obj.resultUrls[0])|| (obj&&obj.video_url) || (obj&&obj.url) || '';})(); return (v?String(v).replace(/[`"']/g,'').trim():''); })() }}`

2) 更新 Is Ready? (Image)
- 同上两条条件表达式（仅节点名不同）

3) 更新 Return Video URL (Text)
- 将 `video_url` 值改为清洗后的直链：
`={{ ( () => { var v=($json&&$json.data&&$json.data.video_url)||$json.video_url||($json&&$json.data&&$json.data.url)||(function(){var raw=$json&&$json.data?$json.data.resultJson:undefined;var obj=(typeof raw==='string')?JSON.parse(raw):raw;return (obj&&obj.resultUrls&&obj.resultUrls[0])||(obj&&obj.video_url)||(obj&&obj.url)||'';})(); return (v?String(v).replace(/[`"']/g,'').trim():''); })() }}`

4) 更新 Return Video URL (Image)
- 使用与文本分支相同的清洗表达式

## 说明
- 通过 A 条件把多源状态合并为一个布尔结果，再与 B 条件（清洗后直链非空）做 AND，避免 OR/AND 嵌套分组问题。
- 清洗步骤移除反引号与引号，并 trim，确保直链可用。
- 保持超时/失败分支逻辑不变（5 分钟/30 秒轮询）。

## 验证
- 用你给出的示例：`status: SUCCESS`、`data.status: completed`、`data.video_url: 带反引号` → 现在将被判定为完成，并输出去引号后的 mp4 直链。
- 仍为 queued 时继续轮询；超过 5 分钟或 failed 走错误分支。

## 不做的改动
- 不新增/删除节点，不改连线，不动 Wait/Check/Failed or Timeout 的结构，仅更新 4 个表达式。